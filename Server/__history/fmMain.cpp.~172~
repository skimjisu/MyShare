#include <vcl.h>
#pragma hdrstop

#include "fmMain.h"

#pragma package(smart_init)
#pragma resource "*.dfm"

TMainForm *MainForm;

__fastcall TMainForm::TMainForm(TComponent* Owner) : TForm(Owner) {
	// 생성자: 몇 가지 변수 초기화
	IS_Hashed = true; // 파일 해시 여부 초기화
	IS_Shering = false; // 파일 공유 여부 초기화
	this->Width = 800; // 폼의 너비 초기화
}

void __fastcall TMainForm::FormCreate(TObject *Sender) {

	try {
		// 공유 정보를 위한 INI 파일을 생성 시도
		Shere_ini = new TIniFile(ExtractFilePath(ParamStr(0)) + "ShereInfo.ini");
	}
	catch (...) {
		// INI 파일 생성 중 예외 처리
		return;
	}

	// 다양한 객체의 인스턴스 생성
	Container = new TContainer; // 파일 컨테이너 초기화
	SysIconList = new TExtIconList; // 시스템 아이콘 리스트 초기화
	TV_ShereList->Images = SysIconList->IconList; // TreeView에 아이콘 리스트 설정

	// 아이콘 초기화
	initializeIcons(); // 사용자 정의 아이콘 초기화 함수 호출
	Load_INI(); // INI 파일에서 정보 로드 함수 호출

	// 레이블을 빈 문자열로 설정하고 공유 버튼 업데이트
	LB_WorkName->Caption = "";
	LB_Percent->Caption = "";
	LB_NowFileName->Caption = "";

	updateShareBtcp(); // 공유 버튼 캡션 업데이트 함수 호출

	// UI 요소 초기화
	WorkForWait(false); // 대기 중일 때 작업을 수행하는 함수 호출
	PN_WorkProce->Visible = false;
	Btn_ShereClick(this); // 공유 버튼 클릭 함수 호출
}

// 사용자 정의 아이콘 초기화 함수
void __fastcall TMainForm::initializeIcons() {
    TIcon *icon = new TIcon;
    IconRes->GetIcon(0, icon);
	SysIconList->AddCustomSystemIcon("__Directory", icon); // 디렉터리 아이콘 추가
    delete icon;

    icon = new TIcon;
    IconRes->GetIcon(1, icon);
	SysIconList->AddCustomSystemIcon("__Directory_Open", icon); // 열린 디렉터리 아이콘 추가
    delete icon;
}

// 공유 버튼 캡션을 업데이트하는 함수
void __fastcall TMainForm::updateShareBtcp() {
	if (!IS_Shering)
		Btn_Shere->Caption = "공유 시작";
    else
		Btn_Shere->Caption = "공유 중지";
}

void __fastcall TMainForm::FormDestroy(TObject *Sender) {
	// 소멸자: 할당된 메모리 해제
	delete Container; // 파일 컨테이너 메모리 해제
	delete Shere_ini; // INI 파일 메모리 해제
	delete SysIconList; // 시스템 아이콘 리스트 메모리 해제
}

// INI 파일에서 정보를 로드하는 함수
void __fastcall TMainForm::Load_INI() {
	TV_ShereList->Items->Clear(); // TreeView 초기화
	Container->ClearShereList(); // 파일 컨테이너 초기화

	TStringList *List = new TStringList;
	TStringList *ItemList = new TStringList;

	// INI 파일에서 섹션 이름 읽기
	Shere_ini->ReadSection(INI_SHERE_LIST_NAME, List);

	for (int i = 0; i < List->Count; i++) {
		TTreeNode *rootNode = AddRootNode(TV_ShereList, List->Strings[i], false);
		ItemList->Clear();
		Shere_ini->ReadSection(List->Strings[i], ItemList);
		for (int j = 0; j < ItemList->Count; j++) {
			handleItem(List, ItemList, rootNode, i, j);
        }
    }
	delete ItemList;
	delete List;
}

// INI에서 각 항목을 처리하는 함수
void __fastcall TMainForm::handleItem(TStringList *List, TStringList *ItemList, TTreeNode *rootNode, int i, int j) {
	if (FileExists(ItemList->Strings[j])) {
		__int64 FileSize = 0;
		if (TryStrToInt64(Shere_ini->ReadString(List->Strings[i], ItemList->Strings[j], "0"), FileSize)) {
			AnsiString MD5 = Shere_ini->ReadString(INI_FILE_HASH_DONE_NAME, ItemList->Strings[j], "");
			if (MD5 == "")
				IS_Hashed = false;
			TShereItem *Item = new TShereItem(List->Strings[i], ItemList->Strings[j], MD5, FileSize);
			Container->AddItem(List->Strings[i], Item);
			AddSubNode(TV_ShereList, rootNode, ItemList->Strings[j], Item, 0, false);
		}
		else {
			deleteFileKeys(List, ItemList, i, j);
		}
    }
    else {
		deleteFileKeys(List, ItemList, i, j);
	}
}

// 파일과 관련된 키를 INI 파일에서 삭제하는 함수
void __fastcall TMainForm::deleteFileKeys(TStringList *list, TStringList *itemList, int i, int j) {
	Shere_ini->DeleteKey(list->Strings[i], itemList->Strings[j]);
	Shere_ini->DeleteKey(INI_FILE_HASH_DONE_NAME, itemList->Strings[j]);
}

// 대기 중일 때 작업을 수행하는 함수
void __fastcall TMainForm::WorkForWait(bool wait) {
	Panel3->Visible = wait; // 대기 패널 표시 여부 설정
	try {
		((TGIFImage*)Image1->Picture->Graphic)->Animate = wait; // 애니메이션 여부 설정
	}
	catch (...) {
	}
}

// TreeView에 루트 노드를 추가하는 함수
TTreeNode * __fastcall TMainForm::AddRootNode(TTreeView *GroupList, AnsiString Name, bool WriteINI) {
	TTreeNode *Item = GroupList->Items->Add(NULL, Name);
	Item->ImageIndex = this->SysIconList->IsInExtSystemIcon("__Directory");
	Item->SelectedIndex = this->SysIconList->IsInExtSystemIcon("__Directory_Open");
	if (WriteINI)
		Shere_ini->WriteBool(INI_SHERE_LIST_NAME, Name, true);
	return Item;
}

// TreeView에 하위 노드를 추가하는 함수
void __fastcall TMainForm::AddSubNode(TTreeView *GroupList, TTreeNode *RootNode, AnsiString FileName, TObject *Item,
	__int64 FileSize, bool WriteINI) {
	if (RootNode != NULL) {
		TTreeNode *SubNode = GroupList->Items->AddChildObject(RootNode, FileName, Item);
		AnsiString Ext = ExtractFileExt(FileName);
		int i = this->SysIconList->IsInExtSystemIcon(Ext);
		if (i != 0) {
			SubNode->ImageIndex = i;
			SubNode->SelectedIndex = i;
		}
		else {
			i = this->SysIconList->AddExtSystemIcon(Ext);
			SubNode->ImageIndex = i;
			SubNode->SelectedIndex = i;
		}
	}
	if (WriteINI)
		Shere_ini->WriteString(RootNode->Text, FileName, IntToStr(FileSize));
}

// 디렉터리 생성 버튼 클릭 시 호출되는 함수
void __fastcall TMainForm::Btn_MakeDirClick(TObject *Sender) {
	MakeDirForm->IS_OK = false;
	MakeDirForm->Edit1->Text = "";
	MakeDirForm->ShowModal();
	AnsiString stTemp = MakeDirForm->Edit1->Text.Trim();
	if (MakeDirForm->IS_OK && stTemp.Length() > 0) {
		for (int i = 0; i < TV_ShereList->Items->Count; i++) {
			TTreeNode *Node = (TTreeNode*)TV_ShereList->Items->Item[i];
			if (Node->Text == stTemp) {
				ShowMessage("이미 있는 공유 이름입니다.");
				return;
			}
		}
		AddRootNode(TV_ShereList, MakeDirForm->Edit1->Text, true);
	}
}

// 선택된 노드에 대해 항목이 있는지 확인하는 함수
bool __fastcall TMainForm::IsInItem(TTreeNode *Node, AnsiString Name) {
	for (int i = 0; i < Node->Count; i++) {
		if (Node->Item[i]->Text == Name)
			return true;
	}
	return false;
}

// TreeView의 마우스 다운 이벤트를 처리하는 함수
void __fastcall TMainForm::TV_ShereListMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) {
    TTreeView *treeView = (TTreeView*)Sender;
    TTreeNode *node = treeView->GetNodeAt(X, Y);
    if (node == NULL)
        return;
	node->Selected = true;
    if (Button != mbRight)
        return;

	// 선택된 노드에 따라 컨텍스트 메뉴 처리
	HandleNodeSelection(treeView, node);
}

// 선택된 노드에 따라 컨텍스트 메뉴 처리하는 함수
void __fastcall TMainForm::HandleNodeSelection(TTreeView *treeView, TTreeNode *node) {
    if (node->Level == 0) {
		N1->Caption = node->Text + " 공유에 파일 추가....";
		this->PopupMenu1->Popup(((TPoint)Mouse->CursorPos).X, ((TPoint)Mouse->CursorPos).Y);
    }
    else if (treeView->SelectionCount >= 1) {
		int selectedCount = GetCountOfSelectedItems(treeView);
		N5->Caption = IntToStr(selectedCount) + " 개 항목 삭제....";
		this->PopupMenu2->Popup(((TPoint)Mouse->CursorPos).X, ((TPoint)Mouse->CursorPos).Y);
    }
}

// TreeView에서 선택된 항목의 개수를 반환하는 함수
int __fastcall TMainForm::GetCountOfSelectedItems(TTreeView *treeView) {
	int selectedCount = 0;
	for (unsigned int i = 0; i < treeView->SelectionCount; i++) {
		if (treeView->Selections[i]->Level == 1) {
			selectedCount++;
		}
	}
	return selectedCount;
}

// TreeView의 선택 항목이 변경될 때 호출되는 함수
void __fastcall TMainForm::TV_ShereListChange(TObject *Sender, TTreeNode *Node) {
	if (Node->Level == 0) {
		Btn_DeleteDir->Enabled = true;
		TV_ShereList->MultiSelect = false;
	}
	else {
		Btn_DeleteDir->Enabled = false;
		TV_ShereList->MultiSelect = true;
	}
}

// TreeView의 편집 이벤트를 처리하는 함수
void __fastcall TMainForm::TV_ShereListEditing(TObject *Sender, TTreeNode *Node, bool &AllowEdit) {
	AllowEdit = false;
}

// "삭제" 버튼 클릭 시 호출되는 함수
void __fastcall TMainForm::Btn_DeleteDirClick(TObject *Sender) {

	if (TV_ShereList->Selected == NULL) return;

	if (TV_ShereList->Selected->Level == 0) {
		AnsiString confirmationMsg = TV_ShereList->Selected->Text + " 공유를 삭제 하시겠습니까?";
        if (MessageBoxA(this->Handle, confirmationMsg.c_str(), "확인", MB_YESNO | MB_ICONQUESTION) == IDYES) {

			TTreeNode *RootNode = TV_ShereList->Selected;
			DeleteSubNodes(RootNode);

			Container->DeleteShereListFromName(RootNode->Text);
			Shere_ini->DeleteKey(INI_SHERE_LIST_NAME, RootNode->Text);
			Shere_ini->EraseSection(RootNode->Text);
			TV_ShereList->Selected->Delete();
        }
    }
}

// TreeView의 서브 노드를 삭제하는 함수
void __fastcall TMainForm::DeleteSubNodes(TTreeNode *RootNode) {
	for (int i = RootNode->Count - 1; i >= 0; --i) {
		TTreeNode *Node = RootNode->Item[i];
		if (Node->Level == 1) {
			TShereItem *Item = (TShereItem*)Node->Data;
			Container->DeleteItem(Item->Name, Item);
			Shere_ini->DeleteKey(Node->Parent->Text, Node->Text);
			Node->Delete();
		}
	}
}

// "공유에 추가" 컨텍스트 메뉴 클릭 시 호출되는 함수
void __fastcall TMainForm::N1Click(TObject *Sender) {
	TTreeNode *Node = TV_ShereList->Selected;
	AddShereFile(Node);
}

// 선택된 노드에 파일을 추가하는 함수
void __fastcall TMainForm::AddShereFile(TTreeNode *Node) {
	if (Node == NULL || Node->Level != 0)
        return;
	if (!OpenDialog1->Execute())
        return;

	// UI 업데이트 및 파일 처리
	LB_WorkName->Caption = "파일 추가 중...";
	WorkForWait(true);
	TV_ShereList->Items->BeginUpdate();

	for (int i = 0; i < OpenDialog1->Files->Count; i++) {
		AnsiString filePath = OpenDialog1->Files->Strings[i];
		if (!IsInItem(Node, filePath)) {
			ProcessFile(filePath, Node);
		}
        Application->ProcessMessages();
    }
	Node->Expand(true);
	TV_ShereList->Items->EndUpdate();
	WorkForWait(false);
	IS_Hashed = false;
}

// 파일 처리 함수
void __fastcall TMainForm::ProcessFile(const AnsiString &filePath, TTreeNode *Node) {
	__int64 FileSize;
    if (FileExists(filePath)) {
		FileSize = GetLocalFileSize(filePath);
		if (FileSize >= MIN_SHERE_FILE_SIZE && FileSize < MAX_SHERE_FILE_SIZE) {
			TShereItem *Item = new TShereItem(Node->Text, filePath, Shere_ini->ReadString(INI_FILE_HASH_DONE_NAME, filePath, ""), FileSize);
			Container->AddItem(Item->Name, Item);
			AddSubNode(TV_ShereList, Node, filePath, Item, FileSize, true);
		}
    }
}

// "공유 삭제" 컨텍스트 메뉴 클릭 시 호출되는 함수
void __fastcall TMainForm::DeleteShere(TObject *Sender) {
	for (int i = TV_ShereList->SelectionCount - 1; i >= 0; --i) {
		TTreeNode *Node = TV_ShereList->Selections[i];
		if (Node->Level == 1) {
			TShereItem *Item = (TShereItem*)Node->Data;
			Container->DeleteItem(Item->Name, Item);
			Shere_ini->DeleteKey(Node->Parent->Text, Node->Text);
			Node->Delete();
		}
	}
}

// "공유 삭제" 컨텍스트 메뉴 클릭 시 호출되는 함수
void __fastcall TMainForm::N5Click(TObject *Sender) {
	DeleteShere(Sender);
}

// TreeView의 키 다운 이벤트 처리하는 함수
void __fastcall TMainForm::TV_ShereListKeyDown(TObject *Sender, WORD &Key, TShiftState Shift) {
    if (Key == VK_DELETE) {
        TTreeView *treeView = (TTreeView*)Sender;
        if (treeView->SelectionCount >= 1) {
			int selectedCount = GetCountOfSelectedItems(treeView);
			AnsiString stTemp = IntToStr(selectedCount) + " 개의 항목을 삭제 하시겠습니까?";
			if (MessageBoxA(this->Handle, stTemp.c_str(), "확인", MB_YESNO | MB_ICONQUESTION) == IDYES) {
				DeleteShere(Sender);
            }
        }
    }
}

// "공유 시작/중지" 버튼 클릭 시 호출되는 함수
void __fastcall TMainForm::Btn_ShereClick(TObject *Sender) {
	if (IS_Shering) {
		StopSharing();
	}
    else {
		StartSharing();
    }
}

// 공유 시작 함수
void __fastcall TMainForm::StartSharing() {
	Btn_Shere->Caption = "공유 중지";
	IS_Shering = true;

	Btn_MakeDir->Enabled = false;
	Btn_DeleteDir->Enabled = false;
	TV_ShereList->Enabled = false;
	Btn_Shere->Enabled = false;

	if (HashingProce()) {
		Btn_MakeDir->Enabled = false;
		Btn_DeleteDir->Enabled = false;
		TV_ShereList->Enabled = false;
		Btn_Shere->Enabled = true;
		Container->ClearSendingList();
		try {
			HTTPS->Active = true;
		}
		catch (...) {
			ShowMessage("공유 서버를 시작할 수 없습니다");
			Btn_ShereClick(NULL);
		}

	}
	else {
		Btn_ShereClick(NULL);
	}
}

// 공유 중지 함수
void __fastcall TMainForm::StopSharing() {
	Btn_Shere->Caption = "공유 시작";
	IS_Shering = false;
	Btn_Shere->Enabled = true;
	Btn_MakeDir->Enabled = true;
	Btn_DeleteDir->Enabled = true;
	TV_ShereList->Enabled = true;
	try {
		HTTPS->Active = false;
	}
	catch (...) {
	}
}

bool __fastcall TMainForm::HashingProce() {

	TotalFileSize = 0;
	EndPos = 0;

	for (int i = 0; i < TV_ShereList->Items->Count; i++) {
		TTreeNode *RootNode = (TTreeNode*)TV_ShereList->Items->Item[i];
		for (int j = 0; j < RootNode->Count; j++) {
			TTreeNode *Node;
			if (RootNode->Item[j] != NULL)
				Node = RootNode->Item[j];
			TShereItem *p = (TShereItem*)Node->Data;
			TotalFileSize += p->FileSize;
		}
	}

	if (TotalFileSize <= 0)
		return false;

	IS_HashCencel = false;

	WorkTimer->Enabled = true;
	LB_WorkName->Caption = "파일 확인중...";
	WorkForWait(true);
	PN_WorkProce->Visible = true;

	for (int i = 0; i < TV_ShereList->Items->Count; i++) {
		if (IS_HashCencel) {
			PN_WorkProce->Visible = false;
			WorkForWait(false);
			WorkTimer->Enabled = false;
			return false;
		}

		TTreeNode *RootNode = (TTreeNode*)TV_ShereList->Items->Item[i];
		for (int j = 0; j < RootNode->Count; j++) {
			TTreeNode *Node;
			if (RootNode->Item[j] != NULL)
				Node = RootNode->Item[j];
			TShereItem *p = (TShereItem*)Node->Data;
			LB_NowFileName->Caption = p->FileName;
			if (p->MD5 != "")
				EndPos += p->FileSize;
			else {
				p->MD5 = GetMD5HashProce(p->FileName);
			}
		}
	}
	PN_WorkProce->Visible = false;
	WorkForWait(false);
	WorkTimer->Enabled = false;
	IS_HashCencel = false;
	return true;
}

AnsiString __fastcall TMainForm::GetMD5HashProce(AnsiString FileName) {
	// DWORD dwStatus = 0;
	BOOL bResult;
	HCRYPTPROV hProv = 0;
	HCRYPTHASH hHash = 0;
	HANDLE hFile = NULL;
	BYTE rgbFile[BUFSIZE];
	DWORD cbRead = 0;
	BYTE rgbHash[MD5LEN];
	DWORD cbHash = 0;

	AnsiString MD5Hash = "";

	hFile = CreateFileA(FileName.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (INVALID_HANDLE_VALUE == hFile)
		return "";

	if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
		return "";

	if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash)) {
		CloseHandle(hFile);
		CryptReleaseContext(hProv, 0);
		return "";
	}

	try {
		while (bResult = ReadFile(hFile, rgbFile, BUFSIZE, &cbRead, NULL)) {
			if (IS_HashCencel) {

				CryptReleaseContext(hProv, 0);
				CryptDestroyHash(hHash);
				CloseHandle(hFile);

				PN_WorkProce->Visible = false;
				WorkForWait(false);
				WorkTimer->Enabled = false;
				return "";
			}

			if (cbRead == 0)
				break;
			EndPos += cbRead;
			if (!CryptHashData(hHash, rgbFile, cbRead, 0)) {
				// dwStatus = GetLastError();
				CryptReleaseContext(hProv, 0);
				CryptDestroyHash(hHash);
				CloseHandle(hFile);
				return "";
			}
			Application->ProcessMessages();
		}

	}
	catch (Exception &E) {
		bResult = FALSE;
	}

	if (!bResult) {
		CryptReleaseContext(hProv, 0);
		CryptDestroyHash(hHash);
		CloseHandle(hFile);
		return "";
	}

	cbHash = MD5LEN;
	if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0)) {
		AnsiString stTemp = "";
		for (DWORD i = 0; i < cbHash; i++) {
			MD5Hash = MD5Hash + stTemp.sprintf("%c%c", rgbDigits[rgbHash[i] >> 4], rgbDigits[rgbHash[i] & 0xf]);
		}
	}
	else
		MD5Hash = "";
	MD5Hash = MD5Hash.UpperCase();
	CryptDestroyHash(hHash);
	CryptReleaseContext(hProv, 0);
	CloseHandle(hFile);
	if (MD5Hash != "")
		this->Shere_ini->WriteString(INI_FILE_HASH_DONE_NAME, FileName, MD5Hash);
	return MD5Hash;
}

void __fastcall TMainForm::TotalWorkProce() {
	PB_Total->Position = (int)(((double)EndPos / (double)TotalFileSize) * 100);
	LB_Percent->Caption = FormatFloat("00.00 %", (double)EndPos / (double)TotalFileSize * 100);
}

void __fastcall TMainForm::FormResize(TObject *Sender) {
	if (this->Width < 800)
		this->Width = 800;
}

void __fastcall TMainForm::HTTPSCommandGet(TIdContext *AContext, TIdHTTPRequestInfo *ARequestInfo,
	TIdHTTPResponseInfo *AResponseInfo) {
	if (ARequestInfo->Document == "/favicon.ico")
		return;
	Memo1->Lines->Add("UserAgent -> " + ARequestInfo->UserAgent);
	Memo1->Lines->Add("Command -> " + ARequestInfo->Command);
	Memo1->Lines->Add("Document -> " + ARequestInfo->Document);
	Memo1->Lines->Add("Params -> " + ARequestInfo->Params->Text);
	Memo1->Lines->Add("Ranges -> " + ARequestInfo->Range);
	Memo1->Lines->Add("Host -> " + ARequestInfo->Host);

   //	Memo1->Lines->Add("Ranges -> StartPos : " + IntToStr(ARequestInfo->Ranges[0]->Ranges->StartPos) + "  EndPos : " +
	//	IntToStr(ARequestInfo->Ranges[0]->Ranges->EndPos));

	if (ARequestInfo->UserAgent != DOWNLOADER_USER_AGENT_STRING) {

		if (ARequestInfo->Document == "/download") {
			SendFileToWeb(AResponseInfo, Container, ARequestInfo->Params);
			return;
		}

		else if (ARequestInfo->Document == "/") {
			SendWebBodyPage(AResponseInfo, Container);
			return;
		}
		else {
			SendRequestFileWeb(ARequestInfo->Document, AResponseInfo);
			return;
		}

	}
	else {
		if (ARequestInfo->Command == "HEAD") {
			SendFileSizeFromHTTPHeadInfo(AResponseInfo, Container, ARequestInfo->Params);
			return;
		}

		if (ARequestInfo->Command == "GET" && ARequestInfo->Document == "/shere_list") {
			SendShereList(AResponseInfo, Container);
			return;
		}

		else if (ARequestInfo->Command == "GET" && ARequestInfo->Document == "/shere_item_list") {
			SendShereItemList(AResponseInfo, Container, ARequestInfo->Params);
			return;
		}

		else if (ARequestInfo->Command == "GET" && ARequestInfo->Document == "/download") {
			// SendFileToClient(ARequestInfo->Range,AResponseInfo,Container,ARequestInfo->Params);
			return;
		}
	}
}

void __fastcall TMainForm::WorkTimerTimer(TObject *Sender) {
	TotalWorkProce();
}

void __fastcall TMainForm::Btn_HashCencelClick(TObject *Sender) {
	IS_HashCencel = true;
}
